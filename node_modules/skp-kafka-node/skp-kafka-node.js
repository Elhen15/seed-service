const kafka = require('kafka-node');
let consumerGroupStream;

/**
 * @description Creates a kafka producer to write a message.
 * @param {JSON} clientOptions a json object of KafkaClient options.
 * @param {Number=0} partitionerType number which represents the way to read from a partition - default = 0, random = 1, cyclic = 2 (other options available)
 * @returns {Object} a producer object (by resolve), error message (by reject)
 */
function initProducer(clientOptions, partitionerType = 0) {
    return new Promise((resolve, reject) => {
        try {
            const producer = new kafka.Producer(new kafka.KafkaClient(clientOptions), { partitionerType : partitionerType });

            producer.on('ready', () => {
                resolve(producer);
            });
    
            producer.on('error', (err) => {
                producer.close(() => {
                    reject(err);
                });
            });
        } catch(err) {
            reject('unexpected error occur - ' + err);
        }
    });
}

/**
 * @description Writes a json message to a given topic.
 * @param {Producer} producer skp-kafka-node producer object, created by initProducer
 * @param {JSON} messages the message to write.
 * @param {String} topicName the name of the topic to write to - if doesn't exist, it will be created automatically.
 * @returns {Object} error message (by reject)
 */
function writeToTopic(producer, messages, topicName) {
    return new Promise((resolve, reject) => {
        try {
            // send to topic
            producer.send([{topic: topicName , messages: JSON.stringify(messages)}], (err) => {
                if (err) reject(err);
                else {
                    resolve();
                } 
            });
    
            producer.on('error', (err) => {
                reject(err);
            });
        } catch(err) {
            reject(err);
        }
    });
}

/**
 * @description opens a listening to a topic.
 * @param {String} topicName the name of the topic to read from.
 * @param {String} groupId the name of the consumer group, if doesn't exist, it will be created automatically.
 * @param {JSON} options a json object of consumerGroupStream options.
 * @param {Function} callbackFunction the callback function which will execute on the read message.
 * @param {Function} errorFunction the callback function which will execute on error state.
 */
function listenToTopic(topicName, groupId, options, callbackFunction, errorFunction) { 
    try {
        options.groupId = groupId;
        consumerGroupStream = new kafka.ConsumerGroupStream(options, topicName);

        consumerGroupStream.on('data', (message) => {
            callbackFunction(message);
        });
    
        consumerGroupStream.on('error', (err) => {
            errorFunction(err);
        });
    } catch(err) {
        errorFunction(err);
    }
}

/**
 * @description commits the offset of the given message
 * @param {JSON} message kafka message to commit its offset
 */
function commitOffset({topic, partition, offset}) {
    return new Promise((resolve, reject) => {
        consumerGroupStream.commit({topic, partition, offset}, true, (err) => {
            if (err) reject(err);
            else {
                resolve();
            }
        });
    });
}

module.exports = {writeToTopic, listenToTopic, initProducer, commitOffset};
const kafka = require('kafka-node');

/**
 * @description Writes a json message to a given topic.
 * @param {JSON} messages the message to write.
 * @param {string} topicName the name of the topic to write to - if doesn't exist, it will be created automatically.
 * @param {JSON} options a json object of KafkaClient options.
 */
function writeToTopic(messages, topicName, options) {
    return new Promise((resolve, reject) => {
        const producer = new kafka.Producer(new kafka.KafkaClient(options));

        producer.on('ready', () => {
            console.log('connected to ', options.kafkaHost);
            // send to topic
            producer.send([{topic: topicName , messages: JSON.stringify(messages)}], (err, data) => {
                producer.close();
                err ? reject(err) : resolve(JSON.stringify(data));
            });
        });

        producer.on('error', (err) => {
            producer.close(() => {
                reject(err)
                console.log('producer closed on producer error');
            });
        });
    });
}

/**
 * @description reads a message from a given topic.
 * @param {string} topicName the name of the topic to read from.
 * @param {string} groupId the name of the consumer group, if doesn't exist, it will be created automatically.
 * @param {Function} nextStepFunction the callback function which will execute on the read message.
 * @param {Function} errorFunction the callback function which will execute on error state.
 */
function readFromTopic(topicName, groupId, options, nextStepFunction, errorFunction) {
    options.groupId = groupId;
    const consumerGroupStream = new kafka.ConsumerGroupStream(options, topicName);

    consumerGroupStream.on('data', (message) => {
        consumerGroupStream.commit({topic: topicName, partition: 0, offset: message.offset}, true, () => {
            nextStepFunction(message);
        });              
    });

    consumerGroupStream.on('error', (err) => {
        errorFunction({'err': err});
    });
}

module.exports = {writeToTopic, readFromTopic}
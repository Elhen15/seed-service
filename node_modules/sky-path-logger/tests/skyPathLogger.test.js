/* eslint-disable */

const logger = require('./../src/bl/skyPathLogger.js');

// Checks if logLevel is one of the available log level options inside the logger
function isLogLevelPartOfTheLoggerLevels(logLevel, loggerLevels) {
	const levelsArray = Object.getOwnPropertyNames(loggerLevels);
	for (let i = 0; i < levelsArray.length; i++) {
		if (logLevel === levelsArray[i]) {
			return true;
		}
	}
	return false;
}

function getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger) {
	return currentLogger.transports.find((transport) => {
		if (transport.name === 'LogstashTransport') {
			return (transport.host === logstashEndPoint.host && transport.port === logstashEndPoint.port);
		}
	});
}

function isLoggerHasConsoleEndpoint(currentLogger) {
	const logstashEndPoint = currentLogger.transports.find(transport => transport.name === 'console');
	if (logstashEndPoint) { return true; }
	return false;
}

test('initializeLogger() initlializes the logger\'s lower bound log level and logstash end point for a correct argumants', () => {
	expect.assertions(3);
	const logLevel = 'info';
	const logstashEndPoint = { host: 'dummy-logstash', port: 44444 };

	logger.initializeLogger(logLevel, logstashEndPoint);
	const currentLogger = logger.getWinstonLogger();

	expect(currentLogger.level).toEqual(logLevel);
	expect(isLogLevelPartOfTheLoggerLevels(currentLogger.level, currentLogger.levels)).toBe(true);

	const currentLoggerLogstash = getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger);

	expect({ host: currentLoggerLogstash.host, port: currentLoggerLogstash.port }).toEqual(logstashEndPoint);
});

test('initializeLogger() does not initlialize the logger\'s lower bound log level and logstash end point and returns exception for an invalid log level', () => {
	expect.assertions(1);
	const invalidlogLevel = 'NOT SOMETHING FROM THE AVAILABLE LOG LEVEL OPTIONS';
	const logstashEndPoint = { host: 'dummy-logstash', port: 44444 };


	try {
		logger.initializeLogger(invalidlogLevel, logstashEndPoint);
	} catch (err) {
		expect(err.message).toEqual('Cannot insert a log level that is not from the next levels: {fatal, error, warning, info, debug, trace} .');
	}
});

test('initializeLogger() does not initlialize the logger\'s lower bound log level and logstash end point and returns exception for an invalid logstash endpoint', () => {
	expect.assertions(1);
	const logLevel = 'info';
	const invalidlogstashEndPoint = 'NOT A VALID LOGSTASH ENDPOINT';

	try {
		logger.initializeLogger(logLevel, invalidlogstashEndPoint);
	} catch (err) {
		expect(err.message).toEqual('Cannot insert a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
	}
});

test('addLogstashEndPoint() injects a logstash end point to the logger for a correct logstashEndpoint argumant', () => {
	expect.assertions(1);
	const logLevel = 'info';
	const logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
	logger.initializeLogger(logLevel, logstashEndPoint);

	const extralogstashEndPoint = { host: 'second-dummy-logstash', port: 55555 };
	logger.addLogstashEndPoint(extralogstashEndPoint);
	const currentLogger = logger.getWinstonLogger();

	const currentLoggerExtraLogstash = getTheFullLogstashFromLogstashEndpoint(extralogstashEndPoint, currentLogger);

	expect({ host: currentLoggerExtraLogstash.host, port: currentLoggerExtraLogstash.port }).toEqual(extralogstashEndPoint);
});

test('addLogstashEndPoint() does not inject a logstash end point to the logger and returns exception for an invalid logstashEndpoint argumants', () => {
	expect.assertions(1);
	const logLevel = 'info';
	const logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
	logger.initializeLogger(logLevel, logstashEndPoint);
	const extraInvalidlogstashEndPoint = 'NOT A VALID LOGSTASH ENDPOINT';

	try {
		logger.addLogstashEndPoint(extraInvalidlogstashEndPoint);
	} catch (err) {
		expect(err.message).toEqual('Cannot add a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
	}
});

test('removeLogstashEndPoint() removes a logstash end point from the logger for a correct logstashEndpoint argumant', () => {
	expect.assertions(1);
	const logLevel = 'info';
	const logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
	logger.initializeLogger(logLevel, logstashEndPoint);

	logger.removeLogstashEndPoint(logstashEndPoint);
	const currentLogger = logger.getWinstonLogger();

	const currentLoggerLogstash = getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger);

	expect(currentLoggerLogstash).toBe(undefined);
});

test('removeLogstashEndPoint() does not remove the logstash end point from the logger for a incorrect (but valid) logstashEndpoint argumant', () => {
	expect.assertions(1);
	const logLevel = 'info';
	const logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
	logger.initializeLogger(logLevel, logstashEndPoint);

	logger.removeLogstashEndPoint({ host: 'NOT THE ORIGINAL-logstash', port: 77777 });
	const currentLogger = logger.getWinstonLogger();

	const currentLoggerLogstash = getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger);

	expect({ host: currentLoggerLogstash.host, port: currentLoggerLogstash.port }).toEqual(logstashEndPoint);
});

test('removeLogstashEndPoint() does not remove a logstash end point from the logger and returns exception for an invalid logstashEndpoint argumant', () => {
	expect.assertions(1);
	const logLevel = 'info';
	const logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
	logger.initializeLogger(logLevel, logstashEndPoint);

	try {
		logger.removeLogstashEndPoint('REMOVE - NOT A VALID LOGSTASH ENDPOINT');
	} catch (err) {
		expect(err.message).toEqual('Cannot remove a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
	}
});

test('addConsoleEndPoint() addes a console end point to the logger', () => {
	expect.assertions(1);
	const logLevel = 'info';
	logger.initializeLogger(logLevel);
	logger.addConsoleEndPoint();
	const currentLogger = logger.getWinstonLogger();

	expect(isLoggerHasConsoleEndpoint(currentLogger)).toBeTruthy();
});

test('removeConsoleEndPoint() removes a console end point from the logger', () => {
	expect.assertions(1);
	const logLevel = 'info';
	logger.initializeLogger(logLevel);
	logger.addConsoleEndPoint();
	logger.removeConsoleEndPoint();
	const currentLogger = logger.getWinstonLogger();

	expect(isLoggerHasConsoleEndpoint(currentLogger)).toBe(false);
});

test('Every log<loglevel>() function throws validation exception for an invalid ServiceInformation argumant at initializeServiceInformation()', () => {
	expect.assertions(2);
	const logLevel = 'info';
	logger.initializeLogger(logLevel);

	// invalidServiceInformation is missing required field - microserviceData
	const invalidServiceInformation = {
		labels:
            ['@dummy-tag', '@dummy-tag2'],
	};
	try {
		logger.initializeServiceInformation(invalidServiceInformation);
	} catch (err) {
		console.log(err);
		expect(typeof err.message).toEqual('string');
		expect(Object.getOwnPropertyNames(JSON.parse(err.message))[0]).toEqual('ValidationError');
	}
});

test('Every log<loglevel>() function throws validation exception for an invalid argumants - logString, item, labels', () => {
	expect.assertions(2);
	const logLevel = 'info';
	logger.initializeLogger(logLevel);

	const serviceInformation = {
		microserviceData:
        {
        	systemName: 'dummy system',
        	serviceName: 'dummy service',
        	serviceVersion: '1.0',
        	podId: 'OVERRIDE',
        },
		labels:
            ['@dummy-tag', '@dummy-tag2'],
	};

	const invalidLogMessageArgs = {
		logString: { invalid_dummy: 'invalid dummy' },
		item: 'invalid item dummy',
		labels: 'invalid @dummy-item',
	};

	logger.initializeServiceInformation(serviceInformation);
	logger.initializeInstanceInformation();
	try {
		// it does not matter which log<loglevel>() is used because it operates the same inner function (logMessage()) with a different log level.
		// the logger does not have any endpoints because it does not need to log messages in testing environment - so the logging writes to nowhere.
		logger.logInfo(invalidLogMessageArgs.logString, invalidLogMessageArgs.item, invalidLogMessageArgs.labels);
	} catch (err) {
		expect(typeof err.message).toEqual('string');
		expect(Object.getOwnPropertyNames(JSON.parse(err.message))[0]).toEqual('ValidationError');
	}
});

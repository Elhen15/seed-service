const logger = require('./../src/bl/skyPathLogger.js');

// Checks if logLevel is one of the available log level options inside the logger
function isLogLevelPartOfTheLoggerLevels(logLevel, loggerLevels) {
    let levelsArray = Object.getOwnPropertyNames(loggerLevels);
    for (let i = 0; i < levelsArray.length; i++) {
        if (logLevel === levelsArray[i]) {
            return true;
        }
    }
    return false;
}

function getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger) {
    return currentLogger.transports.find(transport => {
        if (transport.name === 'LogstashTransport') {
            return (transport.host === logstashEndPoint.host && transport.port === logstashEndPoint.port);
        }
    });
}

function isLoggerHasConsoleEndpoint(currentLogger) {
    let logstashEndPoint = currentLogger.transports.find(transport => {
        return transport.name === 'console';
    });
    if (logstashEndPoint) { return true };
    return false;
}

test('initializeLogger() initlializes the logger\'s lower bound log level and logstash end point for a correct argumants', function () {
    expect.assertions(3);
    let logLevel = 'info';
    let logstashEndPoint = { host: 'dummy-logstash', port: 44444 };

    logger.initializeLogger(logLevel, logstashEndPoint);
    let currentLogger = logger.getWinstonLogger();

    expect(currentLogger.level).toEqual(logLevel);
    expect(isLogLevelPartOfTheLoggerLevels(currentLogger.level, currentLogger.levels)).toBe(true);

    let currentLoggerLogstash = getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger);

    expect({ host: currentLoggerLogstash.host, port: currentLoggerLogstash.port }).toEqual(logstashEndPoint);
});

test('initializeLogger() does not initlialize the logger\'s lower bound log level and logstash end point and returns exception for an invalid log level', function () {
    expect.assertions(1);
    let invalidlogLevel = 'NOT SOMETHING FROM THE AVAILABLE LOG LEVEL OPTIONS';
    let logstashEndPoint = { host: 'dummy-logstash', port: 44444 };


    try {
        logger.initializeLogger(invalidlogLevel, logstashEndPoint);
    }
    catch (err) {
        expect(err.message).toEqual('Cannot insert a log level that is not from the next levels: {fatal, error, warning, info, debug, trace} .');
    }
});

test('initializeLogger() does not initlialize the logger\'s lower bound log level and logstash end point and returns exception for an invalid logstash endpoint', function () {
    expect.assertions(1);
    let logLevel = 'info';
    let invalidlogstashEndPoint = 'NOT A VALID LOGSTASH ENDPOINT';

    try {
        logger.initializeLogger(logLevel, invalidlogstashEndPoint);
    }
    catch (err) {
        expect(err.message).toEqual('Cannot insert a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
    }
});

test('addLogstashEndPoint() injects a logstash end point to the logger for a correct logstashEndpoint argumant', function () {
    expect.assertions(1);
    let logLevel = 'info';
    let logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
    logger.initializeLogger(logLevel, logstashEndPoint);

    let extralogstashEndPoint = { host: 'second-dummy-logstash', port: 55555 };
    logger.addLogstashEndPoint(extralogstashEndPoint);
    let currentLogger = logger.getWinstonLogger();

    let currentLoggerExtraLogstash = getTheFullLogstashFromLogstashEndpoint(extralogstashEndPoint, currentLogger);

    expect({ host: currentLoggerExtraLogstash.host, port: currentLoggerExtraLogstash.port }).toEqual(extralogstashEndPoint);
});

test('addLogstashEndPoint() does not inject a logstash end point to the logger and returns exception for an invalid logstashEndpoint argumants', function () {
    expect.assertions(1);
    let logLevel = 'info';
    let logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
    logger.initializeLogger(logLevel, logstashEndPoint);
    let extraInvalidlogstashEndPoint = 'NOT A VALID LOGSTASH ENDPOINT';

    try {
        logger.addLogstashEndPoint(extraInvalidlogstashEndPoint);
    }
    catch (err) {
        expect(err.message).toEqual('Cannot add a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
    }
});

test('removeLogstashEndPoint() removes a logstash end point from the logger for a correct logstashEndpoint argumant', function () {
    expect.assertions(1);
    let logLevel = 'info';
    let logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
    logger.initializeLogger(logLevel, logstashEndPoint);

    logger.removeLogstashEndPoint(logstashEndPoint);
    let currentLogger = logger.getWinstonLogger();

    let currentLoggerLogstash = getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger);

    expect(currentLoggerLogstash).toBe(undefined);
});

test('removeLogstashEndPoint() removes a logstash end point from the logger for a incorrect (but valid) logstashEndpoint argumant', function () {
    expect.assertions(1);
    let logLevel = 'info';
    let logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
    logger.initializeLogger(logLevel, logstashEndPoint);

    logger.removeLogstashEndPoint({ host: 'NOT THE ORIGINAL-logstash', port: 77777 });
    let currentLogger = logger.getWinstonLogger();

    let currentLoggerLogstash = getTheFullLogstashFromLogstashEndpoint(logstashEndPoint, currentLogger);

    expect({ host: currentLoggerLogstash.host, port: currentLoggerLogstash.port }).toEqual(logstashEndPoint);
});

test('removeLogstashEndPoint() does not remove a logstash end point from the logger and returns exception for an invalid logstashEndpoint argumant', function () {
    expect.assertions(1);
    let logLevel = 'info';
    let logstashEndPoint = { host: 'dummy-logstash', port: 44444 };
    logger.initializeLogger(logLevel, logstashEndPoint);

    try {
        logger.removeLogstashEndPoint('REMOVE - NOT A VALID LOGSTASH ENDPOINT');
    }
    catch (err) {
        expect(err.message).toEqual('Cannot remove a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
    }
});

test('addConsoleEndPoint() addes a console end point to the logger', function () {
    expect.assertions(1);
    let logLevel = 'info';
    logger.initializeLogger(logLevel);
    logger.addConsoleEndPoint();
    let currentLogger = logger.getWinstonLogger();

    expect(isLoggerHasConsoleEndpoint(currentLogger)).toBeTruthy();
});

test('removeConsoleEndPoint() removes a console end point from the logger', function () {
    expect.assertions(1);
    let logLevel = 'info';
    logger.initializeLogger(logLevel);
    logger.addConsoleEndPoint();
    logger.removeConsoleEndPoint();
    let currentLogger = logger.getWinstonLogger();

    expect(isLoggerHasConsoleEndpoint(currentLogger)).toBe(false);
});

test('Every log<loglevel>() function throws validation exception for an invalid MessageFrame argumant at initializeMessageFrame()', function () {
    expect.assertions(2);
    let logLevel = 'info';
    logger.initializeLogger(logLevel);
    let invalidMessageFrame = {
        microserviceData:
        {
            systemName: 'dummy system',
            serviceName: 'dummy service',
            serviceVersion: '1.0',
            podId: 'OVERRIDE'
        },
        skypathMessageId: 'dafb2cd6-655a-4e7e-8fbf-5dcd84e20d4b',
        additionalIds:
        {
            systemName: 'dummy system 2',
            itemId: '777',
            systemId: '02'
        },
        tags:
            ['@dummy-tag', '@dummy-tag2']
    };
    let logMessageArgs = {
        logString: 'testing log',
        item: { test: 'this is a tets' },
        tags: ['@first-item']
    }

    logger.initializeMessageFrame(invalidMessageFrame);
    try {
        // it does not matter which log<loglevel>() is used because it operates the same inner function (logMessage()) with a different log level.
        // the logger does not have any endpoints because it does not need to log messages in testing environment - so the logging writes to nowhere. 
        logger.logInfo(logMessageArgs.logString, logMessageArgs.item, logMessageArgs.tags);
    }
    catch (err) {
        expect(typeof err.message).toEqual('string');
        expect(Object.getOwnPropertyNames(JSON.parse(err.message))[0]).toEqual('ValidationError');
    }
});

test('Every log<loglevel>() function throws validation exception for an invalid argumants - logString, item, tags', function () {
    expect.assertions(2);
    let logLevel = 'info';
    logger.initializeLogger(logLevel);
    let messageFrame = {
        microserviceData:
        {
            systemName: 'dummy system',
            serviceName: 'dummy service',
            serviceVersion: '1.0',
            podId: 'OVERRIDE'
        },
        skypathMessageId: 'dafb2cd6-655a-4e7e-8fbf-5dcd84e20d4b',
        additionalIds:
        [{
            systemName: 'dummy system 2',
            itemId: '777',
            systemId: '02'
        }],
        tags:
            ['@dummy-tag', '@dummy-tag2']
    };
    let invalidLogMessageArgs = {
        logString: {invalid_dummy: 'invalid dummy'},
        item: 'invalid item dummy',
        tags: 'invalid @dummy-item'
    }

    logger.initializeMessageFrame(messageFrame);
    try {
        // it does not matter which log<loglevel>() is used because it operates the same inner function (logMessage()) with a different log level.
        // the logger does not have any endpoints because it does not need to log messages in testing environment - so the logging writes to nowhere. 
        logger.logInfo(invalidLogMessageArgs.logString, invalidLogMessageArgs.item, invalidLogMessageArgs.tags);
    }
    catch (err) {
        expect(typeof err.message).toEqual('string');
        expect(Object.getOwnPropertyNames(JSON.parse(err.message))[0]).toEqual('ValidationError');
    }
});
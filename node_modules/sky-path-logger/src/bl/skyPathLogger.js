const winston = require('winston');
const winstonLogstash = require('winston-logstash-transport');
const messageCreator = require('./messageCreator.js');
const messageValidator = require('./messageValidator.js');
let logger;

/**
 * @description Creates a logger that writes to the given Logstash adresses and filtes messages by the given log level.
 * @param {string} logLevel The lower bound of the log level that can be written.
 * @param {JSON} logstashEndPoints Unlimited number of {host: <value>, port: <value>} objects that represents the logstashes address.
 */
function initializeLogger(logLevel, ...logstashEndPoints) {
    if (!(isLogLevelPartOfTheLoggerLevels(logLevel, { fatal: 0, error: 1, warning: 2, info: 3, debug: 4, trace: 5 }))) {
        throw new Error('Cannot insert a log level that is not from the next levels: {fatal, error, warning, info, debug, trace} .');
    }
    logstashEndPoints.forEach(currentEndPoint => {
        if ((!currentEndPoint) || (!currentEndPoint.host) || (!currentEndPoint.port)) {
            throw new Error('Cannot insert a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
        }
    });

    let defaultLoggerConfig = getDefaultLoggerConfiguration();
    defaultLoggerConfig.level = logLevel;
    logger = winston.createLogger(defaultLoggerConfig);
    logstashEndPoints.forEach(currentEndPoint => {
        addLogstashEndPoint(currentEndPoint);
    });
}

function getDefaultLoggerConfiguration() {
    return {
        level: 'info',
        levels: {
            fatal: 0,
            error: 1,
            warning: 2,
            info: 3,
            debug: 4,
            trace: 5
        },
        format: winston.format.combine(winston.format.logstash()),
        transports: [],
        exceptionHandlers: [
            new winston.transports.Console
        ],
        exitOnError: false,
        silent: false
    }
}

/**
 * @description Adds a logstash to the logger by the logstash's address.
 * @param {JSON} logstashEndPoint Object in the form of - {host: <value>, port: <value>}
 */
function addLogstashEndPoint(logstashEndPoint) {
    if ((!logstashEndPoint) || (!logstashEndPoint.host) || (!logstashEndPoint.port)) {
        throw new Error('Cannot add a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
    }
    logger.add(new winstonLogstash.LogstashTransport(logstashEndPoint));
}

/**
 * @description Removes a logstash from the logger by the logstash's address.
 * @param {JSON} logstashEndPoint Object in the form of - {host: <value>, port: <value>}
 */
function removeLogstashEndPoint(logstashEndPoint) {
    if ((!logstashEndPoint) || (!logstashEndPoint.host) || (!logstashEndPoint.port)) {
        throw new Error('Cannot remove a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
    }
    const removeableEndPoint = logger.transports.find(transport => {
        if (transport.name === 'LogstashTransport') {
            return (transport.host === logstashEndPoint.host && transport.port === logstashEndPoint.port);
        }
    })

    if (removeableEndPoint) {
        logger.remove(removeableEndPoint);
        return true;
    }
    return false;
}

/**
 * @description Adds the console as an output to the logger.
 */
function addConsoleEndPoint() {
    logger.add(new winston.transports.Console);
}

/**
 * @description Removes the console as an output from the logger.
 */
function removeConsoleEndPoint() {
    const removeableEndPoint = logger.transports.find(transport => {
        return transport.name === 'console';
    })

    if (removeableEndPoint) {
        logger.remove(removeableEndPoint);
        return true;
    }
    return false;
}

function logMessage(logLevel, logString, item, tags) {
    let fullLogMessage = messageCreator.createLoggingMessage(logLevel, logString, item, tags);
    let messageValidation = messageValidator.validateLoggingMessage(fullLogMessage);
    if (messageValidation.isValid) {
        logger.log(logLevel, fullLogMessage);
    }
    else {
        throw new Error(JSON.stringify({ ValidationError: messageValidation.errorDetails }));
    }
}

/**
 * @description Logs a Fatal message to the logger endpoints (logstashes/console).
 * @param {string} logString Describes the log's purpose. REQUIERD
 * @param {JSON} item The main object of the log, the payload.
 * @param {Array} tags Array of message tags (each tag is a String type).
 */
function logFatal(logString, item, tags) {
    logMessage('fatal', logString, item, tags);
}

/**
 * @description Logs a Error message to the logger endpoints (logstashes/console).
 * @param {string} logString Describes the log's purpose. REQUIERD
 * @param {JSON} item The main object of the log, the payload.
 * @param {Array} tags Array of message tags (each tag is a String type).
 */
function logError(logString, item, tags) {
    logMessage('error', logString, item, tags);
}

/**
 * @description Logs a Warning message to the logger endpoints (logstashes/console).
 * @param {string} logString Describes the log's purpose. REQUIERD
 * @param {JSON} item The main object of the log, the payload.
 * @param {Array} tags Array of message tags (each tag is a String type).
 */
function logWarning(logString, item, tags) {
    logMessage('warning', logString, item, tags);
}

/**
 * @description Logs a Info message to the logger endpoints (logstashes/console).
 * @param {string} logString Describes the log's purpose. REQUIERD
 * @param {JSON} item The main object of the log, the payload.
 * @param {Array} tags Array of message tags (each tag is a String type).
 */
function logInfo(logString, item, tags) {
    logMessage('info', logString, item, tags);
}

/**
 * @description Logs a Debug message to the logger endpoints (logstashes/console).
 * @param {string} logString Describes the log's purpose. REQUIERD
 * @param {JSON} item The main object of the log, the payload.
 * @param {Array} tags Array of message tags (each tag is a String type).
 */
function logDebug(logString, item, tags) {
    logMessage('debug', logString, item, tags);
}

/**
 * @description Logs a Trace message to the logger endpoints (logstashes/console).
 * @param {string} logString Describes the log's purpose. REQUIERD
 * @param {JSON} item The main object of the log, the payload.
 * @param {Array} tags Array of message tags (each tag is a String type).
 */
function logTrace(logString, item, tags) {
    logMessage('trace', logString, item, tags);
}

// Returns the logger for testing only.
function getWinstonLogger() {
    return logger;
}

// Checks if logLevel is one of the available log level options inside the logger
function isLogLevelPartOfTheLoggerLevels(logLevel, loggerLevels) {
    let levelsArray = Object.getOwnPropertyNames(loggerLevels);
    for (let i = 0; i < levelsArray.length; i++) {
        if (logLevel === levelsArray[i]) {
            return true;
        }
    }
    return false;
}

module.exports = {
    initializeLogger,
    addLogstashEndPoint,
    removeLogstashEndPoint,
    addConsoleEndPoint,
    removeConsoleEndPoint,
    initializeMessageFrame: messageCreator.initializeMessageFrame,
    defaultMessageFrame: messageCreator.defaultMessageFrame,
    skypathLogSchema: messageValidator.skypathLogSchema,
    logFatal,
    logError,
    logWarning,
    logInfo,
    logDebug,
    logTrace
}

// Making sure that the module exports the winston logger for the project's testing file.
if (module.parent && (module.parent.filename.match(/\\tests\\skyPathLogger.test.js$/))) {
    module.exports.getWinstonLogger = getWinstonLogger;
}
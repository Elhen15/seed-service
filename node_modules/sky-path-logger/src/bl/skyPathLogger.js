const winston = require('winston');
const winstonLogstash = require('winston-logstash-transport');
const messageCreator = require('./messageCreator.js');
const messageValidator = require('./messageValidator.js');

let logger;

// Checks if logLevel is one of the available log level options inside the logger
function isLogLevelPartOfTheLoggerLevels(logLevel, loggerLevels) {
	const levelsArray = Object.getOwnPropertyNames(loggerLevels);
	for (let i = 0; i < levelsArray.length; i++) { // eslint-disable-line no-plusplus
		if (logLevel === levelsArray[i]) {
			return true;
		}
	}
	return false;
}

function getDefaultLoggerConfiguration() {
	return {
		level: 'info',
		levels: {
			fatal: 0,
			error: 1,
			warning: 2,
			info: 3,
			debug: 4,
			trace: 5,
		},
		transports: [],
		exitOnError: false,
		silent: false,
	};
}

/**
 * @description Adds a logstash to the logger by the logstash's address.
 * @argument {JSON} logstashEndPoint Object in the form of - {host: <value>, port: <value>}
 */
function addLogstashEndPoint(logstashEndPoint) {
	if ((!logstashEndPoint) || (!logstashEndPoint.host) || (!logstashEndPoint.port)) { throw new Error('Cannot add a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .'); }

	logger.add(new winstonLogstash.LogstashTransport({
		host: logstashEndPoint.host,
		port: logstashEndPoint.port,
		format: winston.format.json(),
	}));
}

/**
 * @description Creates a logger that writes to the given Logstash adresses and filtes messages by the given log level.
 * @argument {string} logLevel The lower bound of the log level that can be written.
 * @argument {JSON} logstashEndPoints Unlimited number of {host: <value>, port: <value>} objects that represents the logstashes address.
 */
function initializeLogger(logLevel, ...logstashEndPoints) {
	if (!(isLogLevelPartOfTheLoggerLevels(logLevel, { fatal: 0, error: 1, warning: 2, info: 3, debug: 4, trace: 5 }))) {
		throw new Error('Cannot insert a log level that is not from the next levels: {fatal, error, warning, info, debug, trace} .');
	}
	logstashEndPoints.forEach((currentEndPoint) => {
		if ((!currentEndPoint) || (!currentEndPoint.host) || (!currentEndPoint.port)) {
			throw new Error('Cannot insert a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
		}
	});

	const defaultLoggerConfig = getDefaultLoggerConfiguration();
	defaultLoggerConfig.level = logLevel;
	logger = winston.createLogger(defaultLoggerConfig);
	logstashEndPoints.forEach((currentEndPoint) => {
		addLogstashEndPoint(currentEndPoint);
	});
}

/**
 * @description Removes a logstash from the logger by the logstash's address.
 * @argument {JSON} logstashEndPoint Object in the form of - {host: <value>, port: <value>}
 */
function removeLogstashEndPoint(logstashEndPoint) {
	if ((!logstashEndPoint) || (!logstashEndPoint.host) || (!logstashEndPoint.port)) {
		throw new Error('Cannot remove a logstashEndPoint argumant that is not from the form of: {host: <value>, port: <value>} .');
	}

	// eslint-disable-next-line
	const removeableEndPoint = logger.transports.find((transport) => {
		if (transport.name === 'LogstashTransport') {
			return (transport.host === logstashEndPoint.host && transport.port === logstashEndPoint.port);
		}
	});

	if (removeableEndPoint) {
		logger.remove(removeableEndPoint);
		return true;
	}
	return false;
}

/**
 * @description Adds the console as an output to the logger.
 */
function addConsoleEndPoint() {
	logger.add(new winston.transports.Console());
}

/**
 * @description Removes the console as an output from the logger.
 */
function removeConsoleEndPoint() {
	const removeableEndPoint = logger.transports.find(transport => transport.name === 'console');

	if (removeableEndPoint) {
		logger.remove(removeableEndPoint);
		return true;
	}
	return false;
}

/**
 * @description Logs a Fatal message to the logger endpoints (logstashes/console).
 * @argument {string} logString Describes the log's purpose. REQUIERD
 * @argument {JSON} item The main object of the log, the payload.
 * @argument {Array} labels Array of message labels (each tag is a String type).
 */
function logFatal(logString, item, labels) {
	const fullLogMessage = messageCreator.createLoggingMessage('fatal', logString, item, labels);
	logger.log('fatal', fullLogMessage);
}

/**
 * @description Logs a Error message to the logger endpoints (logstashes/console).
 * @argument {string} logString Describes the log's purpose. REQUIERD
 * @argument {JSON} item The main object of the log, the payload.
 * @argument {Array} labels Array of message labels (each tag is a String type).
 */
function logError(logString, item, labels) {
	const fullLogMessage = messageCreator.createLoggingMessage('error', logString, item, labels);
	logger.log('error', fullLogMessage);
}

/**
 * @description Logs a Warning message to the logger endpoints (logstashes/console).
 * @argument {string} logString Describes the log's purpose. REQUIERD
 * @argument {JSON} item The main object of the log, the payload.
 * @argument {Array} labels Array of message labels (each tag is a String type).
 */
function logWarning(logString, item, labels) {
	const fullLogMessage = messageCreator.createLoggingMessage('warning', logString, item, labels);
	logger.log('warning', fullLogMessage);
}

/**
 * @description Logs a Info message to the logger endpoints (logstashes/console).
 * @argument {string} logString Describes the log's purpose. REQUIERD
 * @argument {JSON} item The main object of the log, the payload.
 * @argument {Array} labels Array of message labels (each tag is a String type).
 */
function logInfo(logString, item, labels) {
	const fullLogMessage = messageCreator.createLoggingMessage('info', logString, item, labels);
	logger.log('info', fullLogMessage);
}

/**
 * @description Logs a Debug message to the logger endpoints (logstashes/console).
 * @argument {string} logString Describes the log's purpose. REQUIERD
 * @argument {JSON} item The main object of the log, the payload.
 * @argument {Array} labels Array of message labels (each tag is a String type).
 */
function logDebug(logString, item, labels) {
	const fullLogMessage = messageCreator.createLoggingMessage('debug', logString, item, labels);
	logger.log('debug', fullLogMessage);
}

/**
 * @description Logs a Trace message to the logger endpoints (logstashes/console).
 * @argument {string} logString Describes the log's purpose. REQUIERD
 * @argument {JSON} item The main object of the log, the payload.
 * @argument {Array} labels Array of message labels (each tag is a String type).
 */
function logTrace(logString, item, labels) {
	const fullLogMessage = messageCreator.createLoggingMessage('trace', logString, item, labels);
	logger.log('trace', fullLogMessage);
}

// Returns the logger for testing only.
function getWinstonLogger() {
	return logger;
}

module.exports = {
	initializeLogger,
	addLogstashEndPoint,
	removeLogstashEndPoint,
	addConsoleEndPoint,
	removeConsoleEndPoint,
	initializeServiceInformation: messageCreator.initializeServiceInformation,
	defaultServiceInformation: messageCreator.defaultServiceInformation,
	initializeInstanceInformation: messageCreator.initializeInstanceInformation,
	defaultInstanceInformation: messageCreator.defaultInstanceInformation,
	skypathLogSchema: messageValidator.skypathLogSchema,
	logFatal,
	logError,
	logWarning,
	logInfo,
	logDebug,
	logTrace,
};

// Making sure that the module exports the winston logger for the project's testing file.
if (module.parent && (module.parent.filename.match(/\\tests\\skyPathLogger.test.js$/))) {
	module.exports.getWinstonLogger = getWinstonLogger;
}
